# ğŸ¹ æŠ•å°„ç‰©ç³»ç»Ÿæ·±åº¦è§£æ (Projectile System Deep Dive)

æœ¬æ–‡æ¡£æ—¨åœ¨æ„å»ºä¸€ä¸ª**é€šç”¨ã€é«˜æ€§èƒ½ã€é«˜æ‰©å±•æ€§**çš„æŠ•å°„ç‰©ç³»ç»Ÿç†è®ºæ¡†æ¶ã€‚
åœ¨ Project Vampirefall ä¸­ï¼ŒæŠ•å°„ç‰©ï¼ˆProjectilesï¼‰æ˜¯å¡”é˜²ä¸æˆ˜æ–—çš„æ ¸å¿ƒäº¤äº’è½½ä½“ã€‚ä¸ Hitscanï¼ˆå°„çº¿åˆ¤å®šï¼‰ä¸åŒï¼ŒæŠ•å°„ç‰©æ‹¥æœ‰**é£è¡Œæ—¶é—´ (Travel Time)**ã€**ç‹¬ç«‹è½¨è¿¹**å’Œ**ç‰©ç†äº¤äº’**ã€‚

---

## 1. æ ¸å¿ƒåˆ†ç±»ä¸å®šä¹‰ (Taxonomy)

### 1.1 é€»è¾‘åˆ†å±‚
æŠ•å°„ç‰©ä¸åº”è¯¥æ˜¯ä¸€ä¸ªç®€å•çš„ `MonoBehaviour`ï¼Œå®ƒåº”åŒ…å«ä¸¤ä¸ªåˆ†ç¦»çš„å±‚ï¼š
1.  **é€»è¾‘å±‚ (Data/Simulation):** å¤„ç†ä½ç½®ã€é€Ÿåº¦ã€ç¢°æ’æ£€æµ‹ã€ç”Ÿå‘½å‘¨æœŸã€‚ä¸ºäº†æ€§èƒ½ï¼Œé€šå¸¸ç”± `ProjectileManager` ç»Ÿä¸€é©±åŠ¨ï¼ˆECS æˆ– Struct-basedï¼‰ã€‚
2.  **è¡¨ç°å±‚ (View/Rendering):** å¤„ç†æ¨¡å‹æ¸²æŸ“ã€æ‹–å°¾ç‰¹æ•ˆ (Trail)ã€ç²’å­ç³»ç»Ÿã€‚åªè´Ÿè´£â€œè·Ÿéšâ€é€»è¾‘å±‚çš„ä½ç½®ã€‚

### 1.2 è¿åŠ¨æ¨¡å¼ (Movement Types)
| ç±»å‹ | æè¿° | é€‚ç”¨åœºæ™¯ | æ•°å­¦æ¨¡å‹ |
| :--- | :--- | :--- | :--- |
| **ç›´å°„ (Linear)** | æ²¿ç›´çº¿åŒ€é€Ÿ/å˜é€Ÿé£è¡Œã€‚ | ç®­çŸ¢ã€å­å¼¹ã€æ¿€å…‰æŸã€‚ | $P = P_0 + V \cdot t$ |
| **æŠ›å°„ (Lobbed)** | å—é‡åŠ›å½±å“ï¼Œå‘ˆæŠ›ç‰©çº¿ã€‚ | è¿«å‡»ç‚®ã€æ‰‹é›·ã€æŠ•çŸ³è½¦ã€‚ | $y = v_{0y}t - \frac{1}{2}gt^2$ |
| **è¿½è¸ª (Homing)** | åŠ¨æ€è°ƒæ•´é€Ÿåº¦å‘é‡æŒ‡å‘ç›®æ ‡ã€‚ | é­”æ³•é£å¼¹ã€åˆ¶å¯¼å¯¼å¼¹ã€‚ | Steering Behavior (æ“çºµè¡Œä¸º) |
| **è´å¡å°” (Bezier)** | æ²¿é¢„è®¡ç®—çš„æ›²çº¿é£è¡Œï¼Œæ— ç‰©ç†æ¨¡æ‹Ÿã€‚ | åä¸½çš„æŠ€èƒ½å¼¹é“ã€å›æ—‹é•–ã€‚ | Bezier Curve Interpolation |
| **ç¯ç»• (Orbital)** | å›´ç»•å®¿ä¸»æˆ–å®šç‚¹æ—‹è½¬ã€‚ | æŠ¤ç›¾çƒã€ç¯ç»•æ³•çƒã€‚ | Polar Coordinates (æåæ ‡) |
| **å‚ç›´å‘å°„ (Javelin)** | å…ˆå‚ç›´å‡ç©ºï¼Œå†è½¬ä¸ºè¿½è¸ªã€‚ | æ ‡æªå¯¼å¼¹ (Javelin)ã€å¤©é™æ­£ä¹‰ã€‚ | State Machine (Ascend -> Lock -> Homing) |

---

## 2. å¼¹é“æ•°å­¦ä¸å®ç° (Trajectory Mathematics)

### 2.1 æŠ›ç‰©çº¿å¼¹é“ (Parabolic Arc)
ç»™å®šèµ·ç‚¹ $S$ã€ç»ˆç‚¹ $E$ å’Œé£è¡Œæ—¶é—´ $T$ï¼ˆæˆ–é«˜åº¦ $H$ï¼‰ï¼Œå¦‚ä½•è®¡ç®—åˆé€Ÿåº¦ $V_0$ï¼Ÿ

**å…¬å¼æ¨å¯¼ (åŸºäºæ—¶é—´ $T$):**
1.  **æ°´å¹³é€Ÿåº¦:** $V_x = (E.x - S.x) / T$, $V_z = (E.z - S.z) / T$
2.  **å‚ç›´é€Ÿåº¦:** $V_y = (E.y - S.y - 0.5 \cdot g \cdot T^2) / T$ (æ³¨æ„é‡åŠ› $g$ é€šå¸¸ä¸ºè´Ÿå€¼ï¼Œå…¬å¼ä¸­ $g$ å– $-9.8$)

**ä»£ç ç‰‡æ®µ:**
```csharp
public Vector3 CalculateLobVelocity(Vector3 start, Vector3 end, float time)
{
    Vector3 distance = end - start;
    Vector3 distanceXZ = distance;
    distanceXZ.y = 0;

    float sY = distance.y;
    float sXZ = distanceXZ.magnitude;

    float Vxz = sXZ / time;
    float Vy = (sY / time) + (0.5f * Mathf.Abs(Physics.gravity.y) * time);

    Vector3 result = distanceXZ.normalized;
    result *= Vxz;
    result.y = Vy;

    return result;
}
```

### 2.2 è¿½è¸ªç®—æ³• (Homing Logic)
ç®€å•çš„ `LookAt` ä¼šå¯¼è‡´å¯¼å¼¹åƒè‹è‡ä¸€æ ·æŠ½æã€‚ä¼˜ç§€çš„è¿½è¸ªéœ€è¦**è½¬å¼¯é€Ÿåº¦é™åˆ¶ (Turn Rate Limit)**ã€‚

**å®ç°æ­¥éª¤:**
1.  è®¡ç®—ç†æƒ³é€Ÿåº¦å‘é‡: `DesiredVelocity = (TargetPos - CurrentPos).normalized * Speed`
2.  è®¡ç®—è½¬å‘åŠ›: `Steering = DesiredVelocity - CurrentVelocity`
3.  é™åˆ¶è½¬å‘åŠ›: `Steering = Vector3.ClampMagnitude(Steering, TurnRate * dt)`
4.  åº”ç”¨é€Ÿåº¦: `CurrentVelocity += Steering`

#### 2.2.1 æ—‹è½¬æ•°å­¦ (Rotation Math)
ä¸ºäº†è®©å¯¼å¼¹å¹³æ»‘è½¬å‘ç›®æ ‡ï¼Œæˆ‘ä»¬åº”ä½¿ç”¨å››å…ƒæ•° (Quaternion)ã€‚
*   **Slerp:** `Quaternion.Slerp(currentRot, targetRot, turnSpeed * dt)`ã€‚é€‚åˆå¹³æ»‘æ’å€¼ï¼Œä½†åœ¨å¤§è§’åº¦è½¬å‘æ—¶å¯èƒ½ä¸å¤Ÿç›´æ¥ã€‚
*   **RotateTowards:** `Quaternion.RotateTowards(currentRot, targetRot, maxDegreesDelta)`ã€‚æ›´ç²¾ç¡®åœ°æ§åˆ¶æ¯å¸§æœ€å¤§è½¬è§’ï¼Œé€‚åˆæ¨¡æ‹Ÿå¯¼å¼¹çš„æœºæ¢°é™åˆ¶ã€‚

### 2.3 é«˜çº§é¢„åˆ¤ç®—æ³• (Advanced Prediction)
**é¢„ç„å‡†ç†è®º (Lead Aiming):**
*   ç›®æ ‡ä½ç½® $P_T$ï¼Œç›®æ ‡é€Ÿåº¦ $V_T$ï¼Œå­å¼¹é€Ÿåº¦ $S_B$ï¼Œå­å¼¹ä½ç½® $P_B$ã€‚
*   æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªæ—¶é—´ $t$ï¼Œä½¿å¾— $Distance(P_B, P_T + V_T \cdot t) = S_B \cdot t$ã€‚
*   è¿™è½¬åŒ–ä¸ºè§£æ–¹ç¨‹ï¼š$| (P_T - P_B) + V_T \cdot t |^2 = (S_B \cdot t)^2$ã€‚
*   æ±‚è§£ $t$ åï¼Œé¢„æµ‹ç‚¹ $P_{Aim} = P_T + V_T \cdot t$ã€‚

**è¿­ä»£æ±‚è§£ (Iterative Solver):**
å½“ç›®æ ‡ä¸æ˜¯åŒ€é€Ÿç›´çº¿è¿åŠ¨ï¼ˆä¾‹å¦‚åœ¨åšåœ†å‘¨è¿åŠ¨æˆ–å˜é€Ÿè¿åŠ¨ï¼‰ï¼Œè§£æè§£å˜å¾—æå…¶å¤æ‚ã€‚æ­¤æ—¶åº”ä½¿ç”¨è¿­ä»£æ³•ï¼š
1.  å‡è®¾ç¢°æ’æ—¶é—´ $t_0 = Distance / Speed$ã€‚
2.  é¢„æµ‹ $t_0$ åçš„ç›®æ ‡ä½ç½® $P_1$ã€‚
3.  æ›´æ–°ç¢°æ’æ—¶é—´ $t_1 = Distance(Start, P_1) / Speed$ã€‚
4.  é‡å¤æ­¥éª¤ 2-3ï¼Œç›´åˆ° $t_n - t_{n-1}$ å°äºé˜ˆå€¼ã€‚é€šå¸¸ 3-5 æ¬¡è¿­ä»£å³å¯è·å¾—æé«˜ç²¾åº¦ã€‚

### 2.4 ç‰©ç†æ¨¡æ‹Ÿè¿›é˜¶ (Advanced Physics)
ä¸ºäº†è¿½æ±‚æ›´çœŸå®æˆ–ç‰¹æ®Šçš„æ‰‹æ„Ÿï¼Œæˆ‘ä»¬éœ€è¦å¼•å…¥ç©ºæ°”åŠ¨åŠ›å­¦ã€‚

#### ç©ºæ°”é˜»åŠ› (Drag)
çœŸç©ºä¸­çš„æŠ›ç‰©çº¿æ˜¯å®Œç¾çš„å¯¹ç§°å›¾å½¢ï¼Œä½†åœ¨æ¸¸æˆä¸­è¿™çœ‹èµ·æ¥å¯èƒ½å¾ˆâ€œé£˜â€ã€‚
*   **æ¨¡å‹:** $F_d = -k \cdot v^2$ (é˜»åŠ›ä¸é€Ÿåº¦å¹³æ–¹æˆæ­£æ¯”ï¼Œæ–¹å‘ç›¸å)ã€‚
*   **æ•ˆæœ:** æŠ•å°„ç‰©ä¼šæœ‰ä¸€ä¸ªâ€œç»ˆç«¯é€Ÿåº¦â€ï¼Œä¸”ä¸‹è½è½¨è¿¹æ¯”ä¸Šå‡è½¨è¿¹æ›´å‚ç›´ã€‚

#### æ•°å€¼ç§¯åˆ† (Integration)
*   **Explicit Euler:** `Pos += Vel * dt; Vel += Acc * dt;` ç®€å•ä½†è¯¯å·®å¤§ï¼Œä¸æ¨èç”¨äºé•¿è·ç¦»é«˜ç²¾åº¦å¼¹é“ã€‚
*   **Velocity Verlet:** èƒ½é‡å®ˆæ’æ€§æ›´å¥½ï¼Œå¼¹é“æ›´ç¨³å®šã€‚
    ```csharp
    Pos += Vel * dt + 0.5 * Acc * dt * dt;
    NewAcc = ComputeForces(Pos, Vel);
    Vel += 0.5 * (Acc + NewAcc) * dt;
    ```

---

## 3. äº¤äº’æœºåˆ¶ (Interaction Mechanics)

å½“æŠ•å°„ç‰©æ£€æµ‹åˆ°ç¢°æ’åï¼Œä¸ä»…æ˜¯é€ æˆä¼¤å®³ï¼Œè¿˜å¯ä»¥è§¦å‘å¤æ‚çš„åç»­è¡Œä¸ºã€‚

### 3.1 ç©¿é€ (Piercing / Passthrough)
*   **é€»è¾‘:** æŠ•å°„ç‰©å‡»ä¸­æ•Œäººåä¸é”€æ¯ï¼Œè€Œæ˜¯æ‰£å‡ `PierceCount` å¹¶ç»§ç»­é£è¡Œã€‚
*   **å…³é”®ç—›ç‚¹:** **éœ°å¼¹æªæ•ˆåº” (Shotgunning)**ã€‚
    *   *é—®é¢˜:* å¦‚æœä¸€å¸§å†…æ£€æµ‹å¤šæ¬¡ï¼ˆå°„çº¿æ­¥è¿›ï¼‰ï¼Œæˆ–è€…æŠ•å°„ç‰©ä½“ç§¯å¾ˆå¤§ï¼Œå¯èƒ½ä¼šåœ¨åŒä¸€å¸§å¯¹åŒä¸€æ•Œäººè§¦å‘å¤šæ¬¡ä¼¤å®³ã€‚
    *   *è§£å†³:* æ¯ä¸ªæŠ•å°„ç‰©ç»´æŠ¤ä¸€ä¸ª `List<int> hitInstanceIDs`ã€‚å‡»ä¸­æ—¶æ£€æŸ¥ IDï¼Œè‹¥å·²å­˜åœ¨åˆ™è·³è¿‡ã€‚

### 3.2 å¼¹å°„ (Ricochet / Bounce)
*   **é€»è¾‘:** å‡»ä¸­éšœç¢ç‰©æˆ–æ•Œäººåï¼Œæ”¹å˜æ–¹å‘ç»§ç»­é£è¡Œã€‚
*   **ç‰©ç†åå°„:**
    *   å…¬å¼: $R = I - 2(I \cdot N)N$
    *   $I$: å…¥å°„å‘é‡ (Velocity.normalized)
    *   $N$: ç¢°æ’é¢æ³•çº¿ (HitInfo.normal)
*   **æ™ºèƒ½å¼¹å°„ (Chain/Smart Bounce):**
    *   *åœºæ™¯:* é—ªç”µé“¾ï¼Œå¸Œç»´å°”çš„å¼¹å°„ã€‚
    *   *é€»è¾‘:* ä¸éµå¾ªç‰©ç†åå°„ã€‚ä»¥å‘½ä¸­ç‚¹ä¸ºä¸­å¿ƒï¼Œ`OverlapSphere` å¯»æ‰¾æœ€è¿‘çš„ã€æœªè¢«å‡»ä¸­è¿‡çš„æ•Œäººä½œä¸ºä¸‹ä¸€ä¸ªç›®æ ‡æ–¹å‘ã€‚

### 3.3 å‚ç›´å‘å°„è¿½è¸ª (Javelin Style)
è¿™æ˜¯ä¸€ç§ä¸¤é˜¶æ®µå¼¹é“ï¼Œå¸¸ç”¨äºâ€œæ”»é¡¶â€å¯¼å¼¹ã€‚

**é€»è¾‘æµç¨‹:**
1.  **å‡ç©ºé˜¶æ®µ (Ascend Phase):**
    *   ç»™ä¸€ä¸ªåˆå§‹å‘ä¸Šçš„é€Ÿåº¦ `Vector3.up * LaunchForce`ã€‚
    *   æ–½åŠ è¾ƒå°çš„é‡åŠ›æˆ–ç”šè‡³åé‡åŠ›ï¼Œä½¿å…¶å¿«é€Ÿçˆ¬å‡åˆ°æŒ‡å®šé«˜åº¦ï¼ˆå¦‚ 20ç±³ï¼‰ã€‚
    *   åœ¨æ­¤é˜¶æ®µå¿½ç•¥ç›®æ ‡ä½ç½®ï¼Œçº¯ç²¹å‘ä¸Šã€‚
2.  **å·¡èˆª/ä¸‹è½é˜¶æ®µ (Cruise/Descend Phase):**
    *   å½“åˆ°è¾¾æœ€é«˜ç‚¹æˆ–é£è¡Œæ—¶é—´ > $t_1$ã€‚
    *   å¼€å¯ **Homing Logic**ã€‚
    *   è®¾ç½®æé«˜çš„ `TurnRate`ï¼ˆæˆ–è€…ç›´æ¥ `Slerp` æ—‹è½¬ï¼‰ï¼Œè®©å¯¼å¼¹å¤´æœä¸‹å¯¹å‡†ç›®æ ‡ã€‚
    *   é‡åŠ›æ¢å¤æ­£å¸¸ï¼Œåˆ©ç”¨é‡åŠ›åŠ é€Ÿä¸‹è½ã€‚

---

## 4. ç¢°æ’æ£€æµ‹æ–¹æ¡ˆ (Collision Detection)

åœ¨é«˜æ€§èƒ½è¦æ±‚ä¸‹ï¼ˆåŒå± 1000+ å¼¹å¹•ï¼‰ï¼Œä¸èƒ½ç»™æ¯ä¸ªå­å¼¹æŒ‚ `Rigidbody` + `Collider`ã€‚

### 4.1 å°„çº¿æ­¥è¿› (Raycast Step) â€”â€” *æ¨èæ ‡å‡†*
*   **åŸç†:** æ¯ä¸€å¸§ï¼Œä»â€œä¸Šä¸€å¸§ä½ç½®â€å‘â€œå½“å‰å¸§ä½ç½®â€å‘å°„å°„çº¿ã€‚
*   **å…¬å¼:** `Physics.Raycast(prevPos, (currPos - prevPos).normalized, dist)`
*   **ä¼˜ç‚¹:** 
    *   **é˜²ç©¿æ¨¡ (Anti-Tunneling):** å³ä½¿é€Ÿåº¦æå¿«ï¼Œå°„çº¿ä¹Ÿä¼šè¦†ç›–æ•´ä¸ªè·¯å¾„ï¼Œä¸ä¼šç©¿å¢™ã€‚
    *   **æ€§èƒ½:** æ¯” Collider ç‰©ç†å¼•æ“å¼€é”€å°å¾—å¤šã€‚
*   **ç¼ºç‚¹:** å°„çº¿æ²¡æœ‰ä½“ç§¯ï¼ˆå¯¹äºå¾ˆç»†çš„å°„çº¿ï¼Œå¯èƒ½ç©¿è¿‡æ€ªç‰©çš„ç¼éš™ï¼‰ã€‚

### 4.2 çƒå½¢æ­¥è¿› (SphereCast Step) â€”â€” *é«˜å®½å®¹åº¦*
*   **åŸç†:** åŒä¸Šï¼Œä½†ä½¿ç”¨ `Physics.SphereCast`ã€‚
*   **é€‚ç”¨:** ç‚®å¼¹ã€ç«çƒç­‰å¤§ä½“ç§¯æŠ•å°„ç‰©ã€‚ç»™äºˆç©å®¶æ›´å®½æ¾çš„å‘½ä¸­åˆ¤å®šã€‚

### 4.3 èƒ¶å›Šä½“æ­¥è¿› (CapsuleCast Step) â€”â€” *é•¿æ¡ç‰©ä½“*
*   **é€‚ç”¨:** é•¿çŸ›ã€å…‰å‰‘ã€ç®­çŸ¢ã€‚
*   **åŸç†:** `Physics.CapsuleCast`ã€‚ç›¸æ¯”å°„çº¿ï¼Œå®ƒæœ‰ä¸€ä¸ªâ€œç²—ç»†â€ï¼›ç›¸æ¯”çƒä½“ï¼Œå®ƒèƒ½æ›´å¥½åœ°æ¨¡æ‹Ÿé•¿æ¡ç‰©ä½“çš„ä½“ç§¯ï¼Œé¿å…â€œç®­èº«â€ç©¿è¿‡æ•Œäººå´æ²¡åˆ¤å®šçš„æƒ…å†µã€‚

### 4.4 å»¶è¿Ÿè¡¥å¿ (Lag Compensation) - *ç½‘ç»œåŒæ­¥*
è™½ç„¶æœ¬é¡¹ç›®åå•æœºï¼Œä½†è‹¥æ¶‰åŠè”æœºï¼Œéœ€ç†è§£ï¼š
*   æœåŠ¡å™¨åœ¨åˆ¤å®šå‘½ä¸­æ—¶ï¼Œä¼šå°†æ‰€æœ‰æ•Œäººçš„ä½ç½®â€œå›æ»šâ€åˆ°å®¢æˆ·ç«¯å‘å°„å­å¼¹çš„é‚£ä¸ªæ—¶é—´æˆ³ï¼ˆPingå€¼å‰ï¼‰ã€‚
*   è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ åœ¨æœ¬åœ°çœ‹åˆ°æ‰“ä¸­äº†ï¼ŒæœåŠ¡å™¨ä¹Ÿè®¤å¯æ‰“ä¸­äº†ï¼Œå³ä½¿ç°åœ¨æ•Œäººå·²ç»è·‘å¼€äº†ã€‚

---

## 5. æ€§èƒ½æ¶æ„è®¾è®¡ (Performance Architecture)

### 5.1 æŠ•å°„ç‰©ç®¡ç†å™¨ (Projectile Manager)
ä¸è¦è®©æ¯ä¸ª Bullet éƒ½æœ‰ `Update()`ã€‚

```csharp
public struct ProjectileData {
    public Vector3 position;
    public Vector3 velocity;
    public float gravityScale;
    public int pierceCount;
    public int targetMask;
    // ...
}

public class ProjectileManager : MonoBehaviour {
    private ProjectileData[] _projectiles; // æˆ– NativeArray
    private int _activeCount;

    void Update() {
        // 1. æ‰¹é‡æ›´æ–°ä½ç½® (Simulate Physics)
        for (int i = 0; i < _activeCount; i++) {
            UpdateProjectile(ref _projectiles[i], Time.deltaTime);
        }
        // 2. æ‰¹é‡å¤„ç†ç¢°æ’ (Collision Query)
        // 3. æ‰¹é‡æ›´æ–°æ¸²æŸ“å®ä¾‹ (GPU Instancing / Matrix List)
    }
}
```

### 5.2 å¯¹è±¡æ±  (Object Pooling)
*   **å¿…é¡»:** æŠ•å°„ç‰©çš„äº§ç”Ÿå’Œé”€æ¯æå…¶é¢‘ç¹ã€‚
*   **ç­–ç•¥:** 
    *   é€»è¾‘æ•°æ®æ±  (`ProjectileData`)
    *   è§†è§‰è¡¨ç°æ±  (`GameObject` æˆ– `VFX`)
    *   å½“é€»è¾‘ç»“æŸæ—¶ï¼Œå›æ”¶è§†è§‰å¯¹è±¡ã€‚æ³¨æ„å¤„ç† Trail Renderer çš„æ‹–å°¾æ®‹ç•™é—®é¢˜ï¼ˆéœ€è°ƒç”¨ `Clear()`ï¼‰ã€‚

---

## 6. æ€»ç»“ä¸æœ€ä½³å®è·µ (Best Practices)

1.  **åˆ†ç¦»é€»è¾‘ä¸è¡¨ç°:** æ°¸è¿œä¸è¦è®©æ¸²æŸ“å¡é¡¿å½±å“å­å¼¹çš„åˆ¤å®šã€‚é€»è¾‘å±‚å¯ä»¥è·‘åœ¨ FixedUpdate æˆ–ç‹¬ç«‹çº¿ç¨‹ã€‚
2.  **é˜²ç©¿æ¨¡æ˜¯åº•çº¿:** å¯¹äºé«˜é€ŸæŠ•å°„ç‰©ï¼Œå¿…é¡»ä½¿ç”¨å°„çº¿æ­¥è¿›ï¼Œä¸¥ç¦ä»…ä½¿ç”¨ `OnTriggerEnter`ã€‚
3.  **æ™ºèƒ½ä¼˜äºçœŸå®:** å¡”é˜²æ¸¸æˆä¸­ï¼Œå¦‚æœç®­çŸ¢å› ä¸ºç‰©ç†åå¼¹é£å‡ºåœ°å›¾æ˜¯å¾ˆç³Ÿç³•çš„ä½“éªŒã€‚ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½å¼¹å°„ï¼ˆå¿…ä¸­ä¸‹ä¸€ä¸ªæ€ªï¼‰ã€‚
4.  **æ€§èƒ½åˆ†çº§:** 
    *   **Hero Projectiles:** å¯ä»¥ç”¨ç²’å­ã€æ¨¡å‹ã€SphereCastã€‚
    *   **Minion Projectiles:** ä½¿ç”¨ Billboard é¢ç‰‡ã€Raycastã€‚
    *   **Massive Projectiles:** ä½¿ç”¨ GPU Instancing + çº¯è·ç¦»åˆ¤å®šã€‚

---
