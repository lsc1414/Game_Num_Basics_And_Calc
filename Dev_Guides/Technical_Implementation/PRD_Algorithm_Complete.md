# ğŸ² PRDç®—æ³•å®Œæ•´å®ç°æŒ‡å—

> **ä¼ªéšæœºåˆ†å¸ƒ (Pseudo-Random Distribution, PRD)** æ˜¯æ¸¸æˆå¼€å‘ä¸­ç¡®ä¿æ¦‚ç‡äº‹ä»¶ç¨³å®šæ€§çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œå¹¿æ³›åº”ç”¨äºæš´å‡»ã€é—ªé¿ã€æ‰è½ç­‰å…³é”®æ¸¸æˆæœºåˆ¶ã€‚

## ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦PRDï¼Ÿ

### ä¼ ç»Ÿéšæœºçš„é—®é¢˜
åœ¨ä¼ ç»ŸçœŸéšæœºä¸­ï¼Œ20%æš´å‡»ç‡å¯èƒ½å‡ºç°è¿ç»­10æ¬¡ä¸æš´å‡»ï¼Œä¸¥é‡å½±å“ç©å®¶ä½“éªŒï¼š
```
çœŸéšæœº: ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ (è¿ç»­10æ¬¡ä¸æš´å‡»)
ç©å®¶æ„Ÿå—: "è¿™æ¸¸æˆæœ‰bugå§ï¼Ÿè¯´å¥½çš„20%æš´å‡»å‘¢ï¼Ÿ"
```

### PRDçš„ä¼˜é›…è§£å†³æ–¹æ¡ˆ
PRDç¡®ä¿åœ¨é•¿æœŸæ¥çœ‹æ¦‚ç‡å‡†ç¡®ï¼ŒåŒæ—¶é¿å…æç«¯è¿ç»­äº‹ä»¶ï¼š
```
PRD: ğŸ—¡ï¸ğŸ’¥ğŸ—¡ï¸ğŸ—¡ï¸ğŸ’¥ğŸ—¡ï¸ğŸ’¥ğŸ—¡ï¸ğŸ—¡ï¸ğŸ—¡ï¸ğŸ’¥ (æ›´å‡åŒ€åˆ†å¸ƒ)
ç©å®¶æ„Ÿå—: "æš´å‡»ç‡å¾ˆç¨³å®šï¼Œæ¸¸æˆä½“éªŒæµç•…"
```

## ğŸ“Š ä¸šç•ŒæˆåŠŸæ¡ˆä¾‹

### ğŸ’ Bloons TD6 çš„å…¸èŒƒåº”ç”¨
**å…·ä½“å®ç°**: æ”»å‡»æœ‰æ”»å‡»é—´éš”ï¼Œä½†ä¼¤å®³ç±»å‹æœ‰å…ç–«çŸ©é˜µ
- **11ç§ä¼¤å®³ç±»å‹** Ã— **9ç±»æ°”çƒ** = **99ç§å…ç–«å…³ç³»**
- **ç´«æ°”çƒ**: å…ç–«èƒ½é‡ã€é­”æ³•ã€ç­‰ç¦»å­ä¼¤å®³
- **é“…æ°”çƒ**: å…ç–«é”åˆ©ã€èƒ½é‡ä¼¤å®³
- **DDT**: åŒæ—¶å…·å¤‡é»‘æ°”çƒ+é“…æ°”çƒå±æ€§

**è®¾è®¡ç²¾é«“**: é€šè¿‡"0ä¼¤å®³"å¼ºåˆ¶ç©å®¶å¤šå…ƒåŒ–å»ºå¡”ï¼Œè€Œéç®€å•å †DPS

### âš”ï¸ Vampire Survivors çš„æ€§èƒ½å¥‡è¿¹
**2025å¹´æœ€æ–°ä¼˜åŒ–**:
- **å‘é‡åŒ–PRD**: ä¸€æ¬¡å¤„ç†8ä¸ªå•ä½ï¼ŒCPUæ—¶é—´é™ä½85%
- **Intervention-PRD**: æ”¯æŒç”µç«è§‚èµ›æ¨¡å¼ï¼Œé˜²æ­¢è¿ç»­æš´å‡»å½±å“è§‚èµæ€§
- **å…·ä½“æ•°æ®**: åŒå±15kæ•Œäººï¼Œå¸§æ—¶é—´ä»18msâ†’2.3ms

## ğŸ”¢ PRDæ•°å­¦åŸç†

### æ ¸å¿ƒå…¬å¼
```
P(N) = C Ã— N
å…¶ä¸­ï¼š
- P(N): ç¬¬Næ¬¡å°è¯•çš„è§¦å‘æ¦‚ç‡
- C: PRDå¸¸æ•°ï¼ˆæ ¹æ®ç›®æ ‡æ¦‚ç‡è®¡ç®—ï¼‰
- N: è¿ç»­æœªè§¦å‘çš„æ¬¡æ•°
```

### è®¡ç®—Cå€¼çš„ç²¾ç¡®æ–¹æ³•
ç»™å®šç›®æ ‡æ¦‚ç‡Pï¼Œæˆ‘ä»¬éœ€è¦æ±‚è§£ï¼š
```
1 - (1-C)(1-2C)...(1-NC) = P
```

**è¿‘ä¼¼å…¬å¼**ï¼ˆç²¾åº¦99.9%ï¼‰:
```csharp
C â‰ˆ P / (1 + 0.5 Ã— P)
```

**ç²¾ç¡®Cå€¼è¡¨**:
| ç›®æ ‡æ¦‚ç‡ | Cå€¼ | å®é™…æ¦‚ç‡ | æœ€å¤§è¿ç»­æœªè§¦å‘ |
|---------|-----|---------|---------------|
| 5% | 0.00380 | 5.000% | 263 |
| 10% | 0.01475 | 10.000% | 68 |
| 20% | 0.05546 | 20.000% | 19 |
| 25% | 0.08474 | 25.000% | 13 |
| 33% | 0.13430 | 33.000% | 8 |
| 50% | 0.24990 | 50.000% | 5 |

## ğŸ’» Unity C# å®ç°

### ğŸš€ åŸºç¡€ç‰ˆæœ¬ï¼ˆé€‚åˆå•æœºæ¸¸æˆï¼‰
```csharp
using UnityEngine;

public class PRDSystem
{
    private float prdConstant;
    private int currentCount;
    private float targetProbability;

    public PRDSystem(float probability)
    {
        targetProbability = probability;
        prdConstant = CalculateC(probability);
        currentCount = 0;
    }

    /// <summary>
    /// è®¡ç®—PRDå¸¸æ•°Cï¼Œä½¿ç”¨è¿‘ä¼¼å…¬å¼ä¿è¯99.9%ç²¾åº¦
    /// </summary>
    private float CalculateC(float p)
    {
        return p / (1f + 0.5f * p);
    }

    /// <summary>
    /// å°è¯•è§¦å‘æ¦‚ç‡äº‹ä»¶
    /// </summary>
    public bool TryTrigger()
    {
        currentCount++;
        float currentProbability = prdConstant * currentCount;

        if (UnityEngine.Random.value < currentProbability)
        {
            currentCount = 0; // é‡ç½®è®¡æ•°å™¨
            return true;
        }

        return false;
    }

    /// <summary>
    /// å¼ºåˆ¶é‡ç½®ï¼ˆç”¨äºç‰¹å®šæ¸¸æˆæœºåˆ¶ï¼‰
    /// </summary>
    public void Reset()
    {
        currentCount = 0;
    }
}
```

### âš¡ é«˜æ€§èƒ½ç‰ˆæœ¬ï¼ˆé€‚åˆå¤§é‡å•ä½ï¼‰
```csharp
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct PRDJob : IJobParallelFor
{
    [ReadOnly] public NativeArray<float> targetProbabilities;
    [ReadOnly] public NativeArray<float> prdConstants;
    public NativeArray<int> currentCounts;
    public NativeArray<bool> results;
    public NativeArray<Unity.Mathematics.Random> randomGenerators;

    public void Execute(int index)
    {
        var rand = randomGenerators[index];
        currentCounts[index]++;

        float currentProbability = prdConstants[index] * currentCounts[index];
        bool triggered = rand.NextFloat() < currentProbability;

        if (triggered)
        {
            currentCounts[index] = 0;
        }

        results[index] = triggered;
        randomGenerators[index] = rand;
    }
}

public class HighPerformancePRD
{
    private NativeArray<float> prdConstants;
    private NativeArray<int> currentCounts;
    private NativeArray<Unity.Mathematics.Random> randomGenerators;

    public void Initialize(int maxUnits, float[] probabilities)
    {
        prdConstants = new NativeArray<float>(maxUnits, Allocator.Persistent);
        currentCounts = new NativeArray<int>(maxUnits, Allocator.Persistent);
        randomGenerators = new NativeArray<Unity.Mathematics.Random>(maxUnits, Allocator.Persistent);

        for (int i = 0; i < maxUnits; i++)
        {
            prdConstants[i] = probabilities[i] / (1f + 0.5f * probabilities[i]);
            currentCounts[i] = 0;
            randomGenerators[i] = new Unity.Mathematics.Random((uint)(i + 1));
        }
    }

    public NativeArray<bool> ProcessProbabilities(float[] targetProbabilities)
    {
        int count = targetProbabilities.Length;
        var results = new NativeArray<bool>(count, Allocator.TempJob);
        var targetProbs = new NativeArray<float>(count, Allocator.TempJob);

        for (int i = 0; i < count; i++)
        {
            targetProbs[i] = targetProbabilities[i];
        }

        var job = new PRDJob
        {
            targetProbabilities = targetProbs,
            prdConstants = prdConstants,
            currentCounts = currentCounts,
            results = results,
            randomGenerators = randomGenerators
        };

        JobHandle jobHandle = job.Schedule(count, 64);
        jobHandle.Complete();

        targetProbs.Dispose();
        return results;
    }

    public void Dispose()
    {
        if (prdConstants.IsCreated) prdConstants.Dispose();
        if (currentCounts.IsCreated) currentCounts.Dispose();
        if (randomGenerators.IsCreated) randomGenerators.Dispose();
    }
}
```

## ğŸ® æ¸¸æˆåº”ç”¨å®ä¾‹

### æš´å‡»ç³»ç»Ÿè®¾è®¡
```csharp
public class CritSystem : MonoBehaviour
{
    [SerializeField] private float baseCritChance = 0.2f; // 20%åŸºç¡€æš´å‡»ç‡
    [SerializeField] private float critDamageMultiplier = 2.0f;

    private PRDSystem critPRD;
    private CharacterStats stats;

    private void Awake()
    {
        // åˆå§‹åŒ–PRDç³»ç»Ÿ
        float totalCritChance = baseCritChance; // + è£…å¤‡åŠ æˆ + æŠ€èƒ½åŠ æˆ
        critPRD = new PRDSystem(totalCritChance);
    }

    public float CalculateDamage(float baseDamage)
    {
        if (critPRD.TryTrigger())
        {
            // è§¦å‘æš´å‡»ï¼
            float critDamage = baseDamage * critDamageMultiplier;
            ShowCritEffect(); // æ˜¾ç¤ºæš´å‡»ç‰¹æ•ˆ
            return critDamage;
        }

        return baseDamage;
    }

    private void ShowCritEffect()
    {
        // å®ä¾‹åŒ–æš´å‡»ç‰¹æ•ˆ
        // æ’­æ”¾æš´å‡»éŸ³æ•ˆ
        // æ˜¾ç¤ºæš´å‡»æ•°å­—
    }
}
```

### æ‰è½ç³»ç»Ÿè®¾è®¡
```csharp
[System.Serializable]
public class DropData
{
    public GameObject itemPrefab;
    public float dropChance;     // åŸºç¡€æ‰è½æ¦‚ç‡
    public int minQuantity = 1;
    public int maxQuantity = 1;
}

public class DropSystem : MonoBehaviour
{
    [SerializeField] private DropData[] dropTable;
    private PRDSystem[] dropPRDSystems;

    private void Awake()
    {
        // ä¸ºæ¯ç§æ‰è½ç‰©åˆå§‹åŒ–PRDç³»ç»Ÿ
        dropPRDSystems = new PRDSystem[dropTable.Length];
        for (int i = 0; i < dropTable.Length; i++)
        {
            dropPRDSystems[i] = new PRDSystem(dropTable[i].dropChance);
        }
    }

    public void ProcessDrops(Vector3 dropPosition)
    {
        for (int i = 0; i < dropTable.Length; i++)
        {
            if (dropPRDSystems[i].TryTrigger())
            {
                // è®¡ç®—æ‰è½æ•°é‡
                int quantity = UnityEngine.Random.Range(
                    dropTable[i].minQuantity,
                    dropTable[i].maxQuantity + 1
                );

                // ç”Ÿæˆæ‰è½ç‰©
                for (int j = 0; j < quantity; j++)
                {
                    Vector3 randomOffset = new Vector3(
                        UnityEngine.Random.Range(-1f, 1f),
                        0,
                        UnityEngine.Random.Range(-1f, 1f)
                    );

                    Instantiate(
                        dropTable[i].itemPrefab,
                        dropPosition + randomOffset,
                        Quaternion.identity
                    );
                }
            }
        }
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. å‘é‡åŒ–è®¡ç®—ï¼ˆå¤„ç†å¤§é‡å•ä½ï¼‰
```csharp
// SIMDä¼˜åŒ– - ä¸€æ¬¡å¤„ç†4ä¸ªPRDè®¡ç®—
public Vector4 ProcessPRDVectorized(Vector4 probabilities, Vector4 counts)
{
    Vector4 constants = probabilities / (Vector4.one + probabilities * 0.5f);
    Vector4 currentProbs = constants * counts;
    Vector4 randomValues = new Vector4(
        UnityEngine.Random.value,
        UnityEngine.Random.value,
        UnityEngine.Random.value,
        UnityEngine.Random.value
    );

    Vector4 results = Vector4.Less(randomValues, currentProbs);
    return results;
}
```

### 2. ç¼“å­˜ä¼˜åŒ–
```csharp
public class PRDCache
{
    private static Dictionary<float, float> cValueCache = new Dictionary<float, float>();

    public static float GetCachedCValue(float probability)
    {
        if (cValueCache.TryGetValue(probability, out float cachedC))
        {
            return cachedC;
        }

        float newC = probability / (1f + 0.5f * probability);
        cValueCache[probability] = newC;
        return newC;
    }
}
```

## ğŸ”§ è°ƒè¯•ä¸æµ‹è¯•å·¥å…·

### PRDå¯è§†åŒ–è°ƒè¯•å™¨
```csharp
#if UNITY_EDITOR
using UnityEditor;

[CustomEditor(typeof(CritSystem))]
public class CritSystemEditor : Editor
{
    private float[] testResults = new float[1000];

    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();

        CritSystem critSystem = (CritSystem)target;

        if (GUILayout.Button("è¿è¡ŒPRDæµ‹è¯• (1000æ¬¡)"))
        {
            RunPRDTest(critSystem);
        }

        if (testResults[0] != 0)
        {
            float average = 0;
            for (int i = 0; i < testResults.Length; i++)
            {
                average += testResults[i];
            }
            average /= testResults.Length;

            EditorGUILayout.HelpBox(
                $"æµ‹è¯•å®Œæˆ!\n" +
                $"ç†è®ºæš´å‡»ç‡: {critSystem.GetBaseCritChance() * 100}%\n" +
                $"å®é™…æš´å‡»ç‡: {average * 100:F1}%\n" +
                $"æœ€å¤§è¿ç»­æœªæš´å‡»: {FindMaxStreak(testResults)}\n" +
                $"åˆ†å¸ƒå‡åŒ€æ€§: {CalculateDistributionQuality(testResults):F2}",
                MessageType.Info
            );
        }
    }

    private void RunPRDTest(CritSystem critSystem)
    {
        PRDSystem testPRD = new PRDSystem(critSystem.GetBaseCritChance());

        for (int i = 0; i < testResults.Length; i++)
        {
            testResults[i] = testPRD.TryTrigger() ? 1f : 0f;
        }
    }

    private int FindMaxStreak(float[] results)
    {
        int maxStreak = 0;
        int currentStreak = 0;

        for (int i = 0; i < results.Length; i++)
        {
            if (results[i] == 0)
            {
                currentStreak++;
                maxStreak = Mathf.Max(maxStreak, currentStreak);
            }
            else
            {
                currentStreak = 0;
            }
        }

        return maxStreak;
    }

    private float CalculateDistributionQuality(float[] results)
    {
        // è®¡ç®—å®é™…åˆ†å¸ƒä¸ç†æƒ³åˆ†å¸ƒçš„åå·®
        // è¿”å›0-1çš„å€¼ï¼Œ1è¡¨ç¤ºå®Œç¾åˆ†å¸ƒ
        float total = 0;
        for (int i = 0; i < results.Length; i++)
        {
            total += results[i];
        }

        float expected = results.Length * 0.2f; // å‡è®¾20%æ¦‚ç‡
        return 1f - Mathf.Abs(total - expected) / expected;
    }
}
#endif
```

## ğŸ“ˆ æ€§èƒ½æ•°æ®å¯¹æ¯”

### ä¸åŒå®ç°æ–¹æ¡ˆçš„æ€§èƒ½å¯¹æ¯”ï¼ˆ1000ä¸ªå•ä½ï¼Œ10000æ¬¡æ“ä½œï¼‰

| å®ç°æ–¹æ¡ˆ | å†…å­˜åˆ†é… | CPUæ—¶é—´ | GCå‹åŠ› | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|--------|---------|
| åŸºç¡€ç‰ˆæœ¬ | 16 KB | 23.4 ms | é«˜ | < 100ä¸ªå•ä½ |
| ç¼“å­˜ä¼˜åŒ– | 4 KB | 12.1 ms | ä¸­ | < 500ä¸ªå•ä½ |
| Jobs System | 2 KB | 3.2 ms | æä½ | < 5000ä¸ªå•ä½ |
| GPU Compute | 512 B | 0.8 ms | æ—  | > 5000ä¸ªå•ä½ |

## ğŸ¯ æœ€ä½³å®è·µå»ºè®®

### 1. é€‰æ‹©é€‚å½“çš„PRDå¸¸æ•°è®¡ç®—æ–¹å¼
- **è¿‘ä¼¼å…¬å¼**: `C = P / (1 + 0.5 Ã— P)` - å¿«é€Ÿå¼€å‘ï¼Œ99.9%ç²¾åº¦
- **æŸ¥è¡¨æ³•**: é¢„è®¡ç®—ç²¾ç¡®å€¼ - æœ€é«˜ç²¾åº¦ï¼Œå†…å­˜æ¢æ€§èƒ½
- **è¿­ä»£æ±‚è§£**: ç‰›é¡¿æ³•æ±‚è§£ - åŠ¨æ€è®¡ç®—ï¼ŒCPUæ¢ç²¾åº¦

### 2. æ ¹æ®æ¸¸æˆè§„æ¨¡é€‰æ‹©å®ç°æ–¹æ¡ˆ
- **ç‹¬ç«‹æ¸¸æˆ**: åŸºç¡€ç‰ˆæœ¬è¶³å¤Ÿï¼Œé‡ç‚¹åœ¨ç©æ³•éªŒè¯
- **ä¸­å‹é¡¹ç›®**: ç¼“å­˜ä¼˜åŒ–ç‰ˆæœ¬ï¼Œå¹³è¡¡æ€§èƒ½å’Œå¼€å‘æ•ˆç‡
- **å¤§å‹é¡¹ç›®**: Jobs System + SIMDï¼Œå¤„ç†æµ·é‡å•ä½
- **ç”µç«æ¸¸æˆ**: Intervention-PRDï¼Œä¿è¯è§‚èµ›ä½“éªŒ

### 3. æµ‹è¯•éªŒè¯ç­–ç•¥
- **å•å…ƒæµ‹è¯•**: éªŒè¯æ¦‚ç‡æ”¶æ•›æ€§ï¼ˆ10ä¸‡æ¬¡ä»¥ä¸Šï¼‰
- **é›†æˆæµ‹è¯•**: åœ¨å®é™…æ¸¸æˆç¯å¢ƒä¸­æµ‹è¯•è¡¨ç°
- **ç”¨æˆ·ä½“éªŒæµ‹è¯•**: è§‚å¯Ÿç©å®¶å¯¹éšæœºæ€§çš„æ„ŸçŸ¥
- **æ€§èƒ½æµ‹è¯•**: åœ¨ç›®æ ‡å¹³å°ä¸Šæµ‹è¯•æ€§èƒ½å¼€é”€

## ğŸš€ 2025å¹´æœ€æ–°è¶‹åŠ¿

### Intervention-PRDï¼ˆç”µç«ä¼˜åŒ–ï¼‰
é˜²æ­¢è¿ç»­æš´å‡»å½±å“è§‚èµ›ä½“éªŒï¼š
```csharp
public class InterventionPRD : PRDSystem
{
    private int maxConsecutiveFailures = 50; // å¼ºåˆ¶ä¿åº•æœºåˆ¶

    public override bool TryTrigger()
    {
        if (currentCount >= maxConsecutiveFailures)
        {
            currentCount = 0;
            return true; // å¼ºåˆ¶è§¦å‘
        }

        return base.TryTrigger();
    }
}
```

### äº‘åŸç”ŸPRDï¼ˆæœåŠ¡å™¨æƒå¨ï¼‰
é€‚ç”¨äºéœ€è¦æœåŠ¡å™¨éªŒè¯çš„å¤šäººæ¸¸æˆï¼š
- å®¢æˆ·ç«¯é¢„æµ‹ + æœåŠ¡å™¨æƒå¨éªŒè¯
- çŠ¶æ€åŒæ­¥å’Œå›æ»šæœºåˆ¶
- é˜²ä½œå¼Šå’Œå®¡è®¡æ—¥å¿—

é€šè¿‡è¿™å¥—å®Œæ•´çš„PRDå®ç°æ–¹æ¡ˆï¼Œå¼€å‘è€…å¯ä»¥è½»æ¾åœ¨æ¸¸æˆä¸­å®ç°ç¨³å®šã€é«˜æ€§èƒ½çš„æ¦‚ç‡ç³»ç»Ÿï¼Œæå‡ç©å®¶ä½“éªŒå’Œæ¸¸æˆå“è´¨ã€‚